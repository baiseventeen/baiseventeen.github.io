<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>操作系统面试题</title>
      <link href="/2025/04/14/%E5%A0%86%E6%8E%92%E5%BA%8F/"/>
      <url>/2025/04/14/%E5%A0%86%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<p>#堆排序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> nju.Sort;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> BaiBai</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2025-04-14 17:03</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 大顶堆</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HeapSort</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span>[] arr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getArr</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">HeapSort</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.arr = arr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">()</span> &#123;</span><br><span class="line">        buildHeap();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> arr.length - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[<span class="number">0</span>];</span><br><span class="line">            arr[<span class="number">0</span>] = arr[i];</span><br><span class="line">            arr[i] = temp;</span><br><span class="line">            adjustHeap(<span class="number">0</span>, i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构建堆</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">buildHeap</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=arr.length / <span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">            adjustHeap(i, arr.length);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 对指定下标的节点进行整理</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">adjustHeap</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> len)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> arr[i];</span><br><span class="line">        <span class="comment">// j表示当前节点的左子节点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">2</span> * i + <span class="number">1</span>; j &lt; len; j++)&#123;</span><br><span class="line">            <span class="comment">// 找到值更大的节点</span></span><br><span class="line">            <span class="keyword">if</span>(j+<span class="number">1</span> &lt; len &amp;&amp; arr[j] &lt; arr[j+<span class="number">1</span>])&#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 子节点与父节点比较</span></span><br><span class="line">            <span class="keyword">if</span>(arr[j] &gt; arr[i])&#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[i];</span><br><span class="line">                arr[i] = arr[j];</span><br><span class="line">                arr[j] = temp;</span><br><span class="line"></span><br><span class="line">                i = j;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 到这里，i表示最开始的节点值应该插入的位置</span></span><br><span class="line">        arr[i] = num;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">HeapSort</span> <span class="variable">arr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HeapSort</span>(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">3</span>,<span class="number">7</span>,<span class="number">5</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">11</span>,<span class="number">2</span>&#125;);</span><br><span class="line">        arr.getArr();</span><br><span class="line">        arr.sort();</span><br><span class="line">        arr.getArr();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 堆 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统面试题</title>
      <link href="/2025/04/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
      <url>/2025/04/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="操作系统面试题"><a href="#操作系统面试题" class="headerlink" title="操作系统面试题"></a>操作系统面试题</h1><h2 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h2><h3 id="进程、线程和协程的区别？"><a href="#进程、线程和协程的区别？" class="headerlink" title="进程、线程和协程的区别？"></a>进程、线程和协程的区别？</h3><p>进程是操作系统中进行==资源分配和调度的基本单位==，它拥有自己的==独立内存空间和系统资源==。每个进程都有==独立的堆和栈==，不与其他进程共享。进程间通信需要通过特定的机制，如管道、消息队列、信号量等。由于进程拥有独立的内存空间，因此其稳定性和安全性相对较高，但同时上下文切换的开销也较大，因为需要保存和恢复整个进程的状态。 切换地址空间</p><p>线程是==进程内的一个执行单元，也是CPU调度和分派的基本单位==。与进程不同，线程==共享进程的内存空间==，包括堆和全局变量。线程之间通信更加高效，因为它们可以直接读写共享内存。线程的上下文切换开销较小，==因为只需要保存和恢复线程的上下文==，而不是整个进程的状态。然而，由于多个线程共享内存空间，因此存在数据竞争和线程安全的问题，需要通过同步和互斥机制来解决。 寄存器状态、PC、堆栈指针</p><p>协程是一种用户态的轻量级线程，其==调度完全由用户程序控制，而不需要内核的参与==。协程拥有自己的寄存器上下文和栈，但与其他协程共享堆内存。协程的切换开销非常小，因为只需要保存和恢复协程的上下文，而无需进行内核级的上下文切换。这使得协程在处理大量并发任务时具有非常高的效率。然而，协程需要程序员==显式地进行调度和管理==，相对于线程和进程来说，其==编程模型更为复杂==。</p><h3 id="单线程与多线程的比较，多线程好在哪？"><a href="#单线程与多线程的比较，多线程好在哪？" class="headerlink" title="单线程与多线程的比较，多线程好在哪？"></a>单线程与多线程的比较，多线程好在哪？</h3><p>提高程序的==运行效率==，可以充分利用==多核处理器==的资源，同时处理多个任务，加快程序的执行速度。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络面试题</title>
      <link href="/2025/04/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
      <url>/2025/04/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="常见的http响应码"><a href="#常见的http响应码" class="headerlink" title="常见的http响应码"></a>常见的http响应码</h2><h3 id="关键特点："><a href="#关键特点：" class="headerlink" title="关键特点："></a>关键特点：</h3><ul><li><p><strong>2xx</strong>：成功类（200基础成功，201/204针对增删操作）</p></li><li><p><strong>3xx</strong>：重定向类（301永久/302临时，304缓存相关）</p></li><li><p><strong>4xx</strong>：客户端责任（400/404常见，403权限问题）</p></li><li><p><strong>5xx</strong>：服务端责任（500通用错误，503/504可用性问题）</p></li></ul><hr><h3 id="1xx-信息性状态码"><a href="#1xx-信息性状态码" class="headerlink" title="1xx 信息性状态码"></a><strong>1xx 信息性状态码</strong></h3><ul><li><strong>100 Continue</strong>：继续请求</li><li><strong>101 Switching Protocols</strong>：协议升级（如HTTP→WebSocket）</li></ul><hr><h3 id="2xx-成功状态码"><a href="#2xx-成功状态码" class="headerlink" title="2xx 成功状态码"></a><strong>2xx 成功状态码</strong></h3><ul><li><strong>200 OK</strong>：请求成功</li><li><strong>201 Created</strong>：资源已创建（如POST成功）</li><li><strong>202 Accepted</strong>：请求已接收（处理中）</li><li><strong>204 No Content</strong>：无返回内容（如DELETE成功）</li><li><strong>206 Partial Content</strong>：部分内容（如分片下载）</li></ul><hr><h3 id="3xx-重定向状态码"><a href="#3xx-重定向状态码" class="headerlink" title="3xx 重定向状态码"></a><strong>3xx 重定向状态码</strong></h3><ul><li><strong>301 Moved Permanently</strong>：永久重定向</li><li><strong>302 Found</strong>：临时重定向</li><li><strong>304 Not Modified</strong>：缓存未过期（直接使用缓存）</li><li><strong>307 Temporary Redirect</strong>：临时重定向（强制保持方法）</li></ul><hr><h3 id="4xx-客户端错误"><a href="#4xx-客户端错误" class="headerlink" title="4xx 客户端错误"></a><strong>4xx 客户端错误</strong></h3><ul><li><strong>400 Bad Request</strong>：请求语法错误</li><li><strong>401 Unauthorized</strong>：未认证</li><li><strong>403 Forbidden</strong>：无权限访问</li><li><strong>404 Not Found</strong>：资源不存在</li><li><strong>405 Method Not Allowed</strong>：请求方法禁用</li><li><strong>408 Request Timeout</strong>：请求超时</li><li><strong>413 Payload Too Large</strong>：请求体过大</li><li><strong>429 Too Many Requests</strong>：请求频率过高</li></ul><hr><h3 id="5xx-服务端错误"><a href="#5xx-服务端错误" class="headerlink" title="5xx 服务端错误"></a><strong>5xx 服务端错误</strong></h3><ul><li><strong>500 Internal Server Error</strong>：服务器内部错误</li><li><strong>502 Bad Gateway</strong>：网关无效响应</li><li><strong>503 Service Unavailable</strong>：服务不可用（如过载）</li><li><strong>504 Gateway Timeout</strong>：网关超时</li><li><strong>505 HTTP Version Not Supported</strong>：协议版本不支持</li></ul><hr><h3 id="详细介绍："><a href="#详细介绍：" class="headerlink" title="详细介绍："></a>详细介绍：</h3><table><thead><tr><th align="left">状态码</th><th align="left">状态码英文名称</th><th align="left">中文描述</th></tr></thead><tbody><tr><td align="left">100</td><td align="left">Continue</td><td align="left">继续。客户端应继续其请求</td></tr><tr><td align="left">101</td><td align="left">Switching Protocols</td><td align="left">切换协议。服务器根据客户端的请求切换协议。只能切换到更高级的协议，例如，切换到HTTP的新版本协议</td></tr><tr><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">200</td><td align="left">OK</td><td align="left">请求成功。一般用于GET与POST请求</td></tr><tr><td align="left">201</td><td align="left">Created</td><td align="left">已创建。成功请求并创建了新的资源</td></tr><tr><td align="left">202</td><td align="left">Accepted</td><td align="left">已接受。已经接受请求，但未处理完成</td></tr><tr><td align="left">203</td><td align="left">Non-Authoritative Information</td><td align="left">非授权信息。请求成功。但返回的meta信息不在原始的服务器，而是一个副本</td></tr><tr><td align="left">204</td><td align="left">No Content</td><td align="left">无内容。服务器成功处理，但未返回内容。在未更新网页的情况下，可确保浏览器继续显示当前文档</td></tr><tr><td align="left">205</td><td align="left">Reset Content</td><td align="left">重置内容。服务器处理成功，用户终端（例如：浏览器）应重置文档视图。可通过此返回码清除浏览器的表单域</td></tr><tr><td align="left">206</td><td align="left">Partial Content</td><td align="left">部分内容。服务器成功处理了部分GET请求</td></tr><tr><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">300</td><td align="left">Multiple Choices</td><td align="left">多种选择。请求的资源可包括多个位置，相应可返回一个资源特征与地址的列表用于用户终端（例如：浏览器）选择</td></tr><tr><td align="left">301</td><td align="left">Moved Permanently</td><td align="left">永久移动。请求的资源已被永久的移动到新URI，返回信息会包括新的URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI代替</td></tr><tr><td align="left">302</td><td align="left">Found</td><td align="left">临时移动。与301类似。但资源只是临时被移动。客户端应继续使用原有URI</td></tr><tr><td align="left">303</td><td align="left">See Other</td><td align="left">查看其它地址。与301类似。使用GET和POST请求查看</td></tr><tr><td align="left">304</td><td align="left">Not Modified</td><td align="left">未修改。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源</td></tr><tr><td align="left">305</td><td align="left">Use Proxy</td><td align="left">使用代理。所请求的资源必须通过代理访问</td></tr><tr><td align="left">306</td><td align="left">Unused</td><td align="left">已经被废弃的HTTP状态码</td></tr><tr><td align="left">307</td><td align="left">Temporary Redirect</td><td align="left">临时重定向。与302类似。使用GET请求重定向</td></tr><tr><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">400</td><td align="left">Bad Request</td><td align="left">客户端请求的语法错误，服务器无法理解</td></tr><tr><td align="left">401</td><td align="left">Unauthorized</td><td align="left">请求要求用户的身份认证</td></tr><tr><td align="left">402</td><td align="left">Payment Required</td><td align="left">保留，将来使用</td></tr><tr><td align="left">403</td><td align="left">Forbidden</td><td align="left">服务器理解请求客户端的请求，但是拒绝执行此请求</td></tr><tr><td align="left">404</td><td align="left">Not Found</td><td align="left">服务器无法根据客户端的请求找到资源（网页）。通过此代码，网站设计人员可设置”您所请求的资源无法找到”的个性页面</td></tr><tr><td align="left">405</td><td align="left">Method Not Allowed</td><td align="left">客户端请求中的方法被禁止</td></tr><tr><td align="left">406</td><td align="left">Not Acceptable</td><td align="left">服务器无法根据客户端请求的内容特性完成请求</td></tr><tr><td align="left">407</td><td align="left">Proxy Authentication Required</td><td align="left">请求要求代理的身份认证，与401类似，但请求者应当使用代理进行授权</td></tr><tr><td align="left">408</td><td align="left">Request Time-out</td><td align="left">服务器等待客户端发送的请求时间过长，超时</td></tr><tr><td align="left">409</td><td align="left">Conflict</td><td align="left">服务器完成客户端的 PUT 请求时可能返回此代码，服务器处理请求时发生了冲突</td></tr><tr><td align="left">410</td><td align="left">Gone</td><td align="left">客户端请求的资源已经不存在。410不同于404，如果资源以前有现在被永久删除了可使用410代码，网站设计人员可通过301代码指定资源的新位置</td></tr><tr><td align="left">411</td><td align="left">Length Required</td><td align="left">服务器无法处理客户端发送的不带Content-Length的请求信息</td></tr><tr><td align="left">412</td><td align="left">Precondition Failed</td><td align="left">客户端请求信息的先决条件错误</td></tr><tr><td align="left">413</td><td align="left">Request Entity Too Large</td><td align="left">由于请求的实体过大，服务器无法处理，因此拒绝请求。为防止客户端的连续请求，服务器可能会关闭连接。如果只是服务器暂时无法处理，则会包含一个Retry-After的响应信息</td></tr><tr><td align="left">414</td><td align="left">Request-URI Too Large</td><td align="left">请求的URI过长（URI通常为网址），服务器无法处理</td></tr><tr><td align="left">415</td><td align="left">Unsupported Media Type</td><td align="left">服务器无法处理请求附带的媒体格式</td></tr><tr><td align="left">416</td><td align="left">Requested range not satisfiable</td><td align="left">客户端请求的范围无效</td></tr><tr><td align="left">417</td><td align="left">Expectation Failed（预期失败）</td><td align="left">服务器无法满足请求头中 Expect 字段指定的预期行为。</td></tr><tr><td align="left">418</td><td align="left">I’m a teapot</td><td align="left">状态码 418 实际上是一个愚人节玩笑。它在 RFC 2324 中定义，该 RFC 是一个关于超文本咖啡壶控制协议（HTCPCP）的笑话文件。在这个笑话中，418 状态码是作为一个玩笑加入到 HTTP 协议中的。</td></tr><tr><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">500</td><td align="left">Internal Server Error</td><td align="left">服务器内部错误，无法完成请求</td></tr><tr><td align="left">501</td><td align="left">Not Implemented</td><td align="left">服务器不支持请求的功能，无法完成请求</td></tr><tr><td align="left">502</td><td align="left">Bad Gateway</td><td align="left">作为网关或者代理工作的服务器尝试执行请求时，从远程服务器接收到了一个无效的响应</td></tr><tr><td align="left">503</td><td align="left">Service Unavailable</td><td align="left">由于超载或系统维护，服务器暂时的无法处理客户端的请求。延时的长度可包含在服务器的Retry-After头信息中</td></tr><tr><td align="left">504</td><td align="left">Gateway Time-out</td><td align="left">充当网关或代理的服务器，未及时从远端服务器获取请求</td></tr><tr><td align="left">505</td><td align="left">HTTP Version not supported</td><td align="left">服务器不支持请求的HTTP协议的版本，无法完成处理</td></tr></tbody></table><h3 id="Restful风格"><a href="#Restful风格" class="headerlink" title="Restful风格"></a>Restful风格</h3><p><a href="https://www.mianshiya.com/question/1799588814148411394">https://www.mianshiya.com/question/1799588814148411394</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>EAI大模型微调</title>
      <link href="/2025/04/08/EAI%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%BE%AE%E8%B0%83%E5%86%85%E5%AE%B9/"/>
      <url>/2025/04/08/EAI%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%BE%AE%E8%B0%83%E5%86%85%E5%AE%B9/</url>
      
        <content type="html"><![CDATA[<h1 id="EAI大模型微调"><a href="#EAI大模型微调" class="headerlink" title="EAI大模型微调"></a>EAI大模型微调</h1><h2 id="调优类型"><a href="#调优类型" class="headerlink" title="调优类型"></a>调优类型</h2><p>LoRA微调</p><h2 id="迭代轮次"><a href="#迭代轮次" class="headerlink" title="迭代轮次"></a>迭代轮次</h2><blockquote><p>训练过程中模型遍历整个数据集的次数。不同量级数据集的建议值：百量集4~8；千量集2~4；更大数量级1~2</p></blockquote><p>设置为2</p><h2 id="学习率"><a href="#学习率" class="headerlink" title="学习率"></a>学习率</h2><blockquote><p>每个迭代步数（iteration）模型参数/权重更新的速率，请输入一个介于0-0.1之间的浮点数。</p></blockquote><p>初始值0.00002</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Java面试-常见场景题</title>
      <link href="/2025/04/08/Java%E9%9D%A2%E8%AF%95%E5%B8%B8%E8%A7%81%E5%9C%BA%E6%99%AF%E9%A2%98/"/>
      <url>/2025/04/08/Java%E9%9D%A2%E8%AF%95%E5%B8%B8%E8%A7%81%E5%9C%BA%E6%99%AF%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="1-CPU飙高如何定位问题？"><a href="#1-CPU飙高如何定位问题？" class="headerlink" title="1.CPU飙高如何定位问题？"></a>1.CPU飙高如何定位问题？</h2><p><strong>1.使用 <code>top</code> 命令定位高 CPU 进程</strong></p><p><strong>2.查看当前线程中的进程信息</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps H -eo pid,tid,%CPU | grep 40940</span><br></pre></td></tr></table></figure><blockquote><p>pid  进行id</p><p>tid   进程中的线程id</p><p>%  cpu使用率 </p><p>H 显示进程的<strong>所有线程</strong>（默认只显示进程，<code>H</code> 选项会展开线程</p><p>-eo pid,tid,%CPU：自定义输出格式，仅显示以下字段</p></blockquote><p><strong>或者使用 <code>top</code> 命令定位线程</strong></p><p>通过以下命令查看该进程下的线程及其 CPU 使用情况：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">top -H -p &lt;PID&gt;</span><br></pre></td></tr></table></figure><p>记录占用 CPU 最高的线程的 LWP 值（线程 ID）。</p><p><strong>3.将线程id转换为16进制</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span> <span class="string">&quot;%x\n&quot;</span> &lt;LWP&gt;</span><br></pre></td></tr></table></figure><p><strong>4.使用 jstack 分析线程堆栈</strong><br>使用以下命令获取堆栈信息并定位线程执行的代码：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jstack &lt;PID&gt; | grep &lt;线程十六进制ID&gt; -A 20</span><br></pre></td></tr></table></figure><p><code>&lt;PID&gt;</code>：进程 ID。<br><code>&lt;线程十六进制ID&gt;</code>：十六进制的线程 ID。<br><code>-A 20</code>：显示匹配行之后的 20 行堆栈信息。</p><h3 id="1-1补充内容"><a href="#1-1补充内容" class="headerlink" title="1.1补充内容"></a>1.1补充内容</h3><p><code>jstack </code> <strong>当前时刻的线程快照</strong></p><p><code>jstat</code>   GC 分析</p><p><code>jmap </code>   （内存分析）综合诊断。</p><h3 id="1-2CPU飙高的原因？"><a href="#1-2CPU飙高的原因？" class="headerlink" title="1.2CPU飙高的原因？"></a>1.2CPU飙高的原因？</h3><p>1.高并发请求：降级熔断，MQ</p><p>2.IO密集型：导致IO阻塞，大量线程切换消耗CPU</p><p>3.数据库慢查询：SQL查询未优化，导致查询线程长时间占用CPU</p><h2 id="2-Java内存溢出排查思路？"><a href="#2-Java内存溢出排查思路？" class="headerlink" title="2.Java内存溢出排查思路？"></a>2.Java内存溢出排查思路？</h2><p>原因：</p><p>如果线程请求分配的栈容量超过java<strong>虚拟机栈</strong>允许的最大容量的时候，java虚拟机将抛出一个<strong>StackOverFlowError</strong>异常<br>如果java虚拟机栈可以动态拓展，并且扩展的动作已经尝试过，但是目前无法申请到足够的内存去完成拓展，或者在建立新线程的时候没有足够的内存去创建对应的虚拟机栈，那java虚拟机将会抛出一个<strong>OutOfMemoryError</strong>异常</p><p>如果一次加载的类太多，<strong>元空间</strong>内存不足，则会报<strong>OutOfMemoryError: Metaspace</strong></p><p><img src="%E5%9C%BA%E6%99%AF%E9%A2%981.png"></p><p><strong>1、通过jmap指定打印他的内存快照 dump</strong></p><p>有的情况是内存溢出之后程序则会直接中断，而jmap只能打印在运行中的程序，所以建议通过参数的方式的生成dump文件，配置如下：</p><blockquote><p>-XX:+HeapDumpOnOutOfMemoryError</p><p>-XX:HeapDumpPath=/home/app/dumps/      指定生成后文件的保存目录</p></blockquote><p><strong>2、通过工具， VisualVM去分析 dump文件</strong></p><p>VisualVM可以加载离线的dump文件</p><p><strong>3、通过查看堆信息的情况，可以大概定位内存溢出是哪行代码出了问题</strong></p><p><img src="%E5%9C%BA%E6%99%AF%E9%A2%982.png"></p><h2 id="3-内存泄漏如何观察到？"><a href="#3-内存泄漏如何观察到？" class="headerlink" title="3.内存泄漏如何观察到？"></a>3.内存泄漏如何观察到？</h2><p>使用Java VisualVM，我们可以对Java Heap进行内存监视，并确定其行为是否存在内存泄漏。</p><p>VisualVM 可以具体定位内存泄漏的发生位置</p><p><strong>第一步 使用visualVM的visualGC插件监控各内存分代</strong></p><p>老年代持续增长，且 Full GC 无法回收，说明存在无法释放的对象。</p><p><strong>或</strong>通过「监视器」页签观察「老年代内存」曲线。若内存使用量持续上涨且 Full GC 后不回落，说明存在无法回收的对象</p><p><strong>第二步：分析gc是否正常执行</strong></p><p>命令：意思是每1000毫秒查询一次，一直查。gcutil的意思是已使用空间站总空间的百分比。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jstat -gcutil &lt;pid&gt; 1000</span><br></pre></td></tr></table></figure><p><img src="../img/%E5%9C%BA%E6%99%AF%E9%A2%983.png"></p><p>jstat执行结果</p><p>查询结果表明：这台服务器的新生代Eden区（E，表示Eden）使用了28.30%（最后）的空间，两个Survivor区（S0、S1，表示Survivor0、Survivor1）分别是0和8.93%，老年代（O，表示Old）使用了87.33%。程序运行以来共发生Minor GC（YGC，表示Young GC）101次，总耗时1.961秒，发生Full GC（FGC，表示Full GC）7次，Full GC总耗时3.022秒，总的耗时（GCT，表示GC Time）为4.983秒。</p><p><strong>找出频繁FullGC的原因</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jmap -histo:live &lt;pid&gt;</span><br></pre></td></tr></table></figure><p>在网上找了一位博友的不正常数据，如下：</p><p><img src="../img/%E5%9C%BA%E6%99%AF%E9%A2%984.webp"></p><p>可以看出HashTable中的元素有5000多万，占用内存大约1.5G的样子。这肯定不正常。</p><p><strong>第四步 堆转储分析（定位问题代码）</strong></p><p><strong>MAT 插件集成</strong>：导出堆转储后，用 MAT（Memory Analyzer Tool）进一步分析，生成泄漏报告（如「Leak Suspects」功能）</p><p><strong>参考：</strong></p><p><a href="https://segmentfault.com/a/1190000039842866">https://segmentfault.com/a/1190000039842866</a></p><p><a href="https://cloud.tencent.com/developer/article/1495973">https://cloud.tencent.com/developer/article/1495973</a></p><p><a href="https://blog.csdn.net/DevelopmentStack/article/details/117385852">https://blog.csdn.net/DevelopmentStack/article/details/117385852</a></p><p><a href="https://zhuanlan.zhihu.com/p/623862279">https://zhuanlan.zhihu.com/p/623862279</a></p><p>上传时，复制到assets</p><p><img src="E:/code/MyHexo/myblog/source/_posts/assets/4bdbd0c00f5b14fe7658cffbfabe8a75-17441301566642.jpg" alt="4bdbd0c00f5b14fe7658cffbfabe8a75"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Java面试-海量数据场景题</title>
      <link href="/2025/04/08/Java%E9%9D%A2%E8%AF%95%E5%9C%BA%E6%99%AF%E9%A2%98/"/>
      <url>/2025/04/08/Java%E9%9D%A2%E8%AF%95%E5%9C%BA%E6%99%AF%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h3 id="1-给定a、b两个文件，各存放50忆各url，每个url占64字节，内存限制是4G，找出a、b文件共同的url"><a href="#1-给定a、b两个文件，各存放50忆各url，每个url占64字节，内存限制是4G，找出a、b文件共同的url" class="headerlink" title="1.给定a、b两个文件，各存放50忆各url，每个url占64字节，内存限制是4G，找出a、b文件共同的url"></a>1.给定a、b两个文件，各存放50忆各url，每个url占64字节，内存限制是4G，找出a、b文件共同的url</h3><p>方法：分治+hashmap</p><p>单文件存储的url大小为320G</p><ul><li><p>遍历文件a，<strong>对每个url求取hash(url)％1000</strong>，然后根据所取得的值将url分别存储到<strong>1000个小文件</strong>（记为a0,a1,…，a999)中。这样每个小文件的大约为<strong>300M</strong>。</p></li><li><p>遍历文件b，采取和a相同的方式将url分别存储到1000小文件(记为b0,b1,…b999)。这样处理后，所有可能相同的url都在对应的小文件(a0-b0，a1-b1,…a999-b999)中，不对应的小文件不可能有相同的url。然后我们只要求出1000对小文件中相同的url即可。</p></li><li><p>求每对小文件中相同的url时，可以把其中一个小文件的url存储到hashset中。然后遍历另一个小文件的每个url，看其是否在刚才构建的hash_set中，如果是，那么就是共同的url，存到文件里面就可以了。</p></li></ul><h3 id="2-有-10-个文件，每个文件-1G，每个文件的每一行存放的都是用户的query，每个文件的-query-都可能重复。要求你按照-query-的频度排序"><a href="#2-有-10-个文件，每个文件-1G，每个文件的每一行存放的都是用户的query，每个文件的-query-都可能重复。要求你按照-query-的频度排序" class="headerlink" title="2.有 10 个文件，每个文件 1G，每个文件的每一行存放的都是用户的query，每个文件的 query 都可能重复。要求你按照 query 的频度排序"></a>2.有 10 个文件，每个文件 1G，每个文件的每一行存放的都是用户的query，每个文件的 query 都可能重复。要求你按照 query 的频度排序</h3><p>方法：先使用hashmap初步分类，然后对每个小文件技术排序，最后对小文件进行归并排序</p><ul><li><p>顺序读取10个文件，按照hash(query)%10的结果将query写入到另外10个文件（记为a0,a1,…,a9）中。这样新生成的文件每个的大小大约也1G（假设hash函数是随机的）。</p></li><li><p>找一台内存在2G左右的机器，依次对a0,a1,…,a9用hash_map(query, query_count)来统计每个query出现的次数。利用快速/堆/归并排序按照出现次数进行排序。将排序好的query和对应的query_count输出到文件中。这样得到了10个排好序的文件（记为b0,b1,…,b9）。</p></li><li><p>对b0,b1,…,b9这10个文件进行归并排序（内排序与外排序相结合）。</p></li></ul><h3 id="3-海量日志数据，提取出某日访问百度次数最多的那个-IP"><a href="#3-海量日志数据，提取出某日访问百度次数最多的那个-IP" class="headerlink" title="3.海量日志数据，提取出某日访问百度次数最多的那个 IP"></a>3.海量日志数据，提取出某日访问百度次数最多的那个 IP</h3><ol><li><p><strong>提取IP地址</strong>：从某一天的百度访问日志中提取所有IP地址，逐个写入一个大文件。</p></li><li><p><strong>IP地址特性</strong>：IP是32位的，最多有2^32^个不同的IP地址。<strong>128G</strong></p></li><li><p><strong>分治处理</strong>：</p></li></ol><ul><li>采用 <strong>模1000映射</strong>（即 <code>IP % 1000</code>），将大文件分割成 <strong>1000个小文件</strong>。</li><li>每个小文件存储相同模值的IP（如 <code>IP % 1000 == 0</code> 的存入 <code>file0</code>，依此类推）。</li></ul><ol start="4"><li><strong>统计频率</strong>：</li></ol><ul><li>对每个小文件，使用 <strong>哈希表（hash_map）</strong> 统计IP的出现频率。</li><li>找出每个小文件中 <strong>频率最高的IP</strong> 及其出现次数。</li></ul><ol start="5"><li>全局筛选：</li></ol><ul><li>从1000个小文件的最高频IP中，再找出 <strong>全局频率最高的IP</strong>，即为所求。</li></ul><h3 id="4-海量数据分布在-100-台电脑中，想个办法高校统计出这批数据的-TOP10"><a href="#4-海量数据分布在-100-台电脑中，想个办法高校统计出这批数据的-TOP10" class="headerlink" title="4.海量数据分布在 100 台电脑中，想个办法高校统计出这批数据的 TOP10"></a>4.海量数据分布在 100 台电脑中，想个办法高校统计出这批数据的 TOP10</h3><ol><li><p><strong>单机求TOP10的方法</strong>：</p><ul><li><p>在每台电脑上求出TOP10，可以采用包含10个元素的堆完成（<strong>TOP10小，用最大堆</strong>；<strong>TOP10大，用最小堆</strong>）。</p></li><li><p>具体步骤：</p><ul><li>例如求TOP10大：<ol><li>取前10个元素调整成最小堆。<strong>小顶堆方便将当前10个中最小的值出去</strong></li><li>扫描后面的数据，并与堆顶元素比较。</li><li>如果当前数据比堆顶元素大，则用该元素替换堆顶，并重新调整为最小堆。</li><li>最终堆中的元素即为TOP10大。</li></ol></li></ul></li></ul></li><li><p><strong>分布式场景（100台电脑）</strong>：</p><ul><li>求出每台电脑上的TOP10后，将这100台电脑的TOP10结果组合（共1000个数据）。</li><li>再次利用上述方法（基于堆的比较与替换）求出全局的最终TOP10。</li></ul></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Typora-设置图床</title>
      <link href="/2025/03/13/%E6%9A%82%E5%AD%98/Typora-%E8%AE%BE%E7%BD%AE%E5%9B%BE%E5%BA%8A/"/>
      <url>/2025/03/13/%E6%9A%82%E5%AD%98/Typora-%E8%AE%BE%E7%BD%AE%E5%9B%BE%E5%BA%8A/</url>
      
        <content type="html"><![CDATA[<h3 id="1-下载PicGo"><a href="#1-下载PicGo" class="headerlink" title="1.下载PicGo"></a><del>1.下载PicGo</del></h3><p><a href="https://github.com/Molunerfinn/PicGo/releases">https://github.com/Molunerfinn/PicGo/releases</a></p><p><img src="https://gitee.com/baibai1293205470/image-save/raw/master/image-20250313174247880.png" alt="image-20250313174247880"></p><h3 id="2-Gitee"><a href="#2-Gitee" class="headerlink" title="2.Gitee"></a>2.Gitee</h3><p>生成私人令牌</p><p>前往语雀-我的个人网站知识库-私人密钥查看</p><h3 id="3-配置PicGo"><a href="#3-配置PicGo" class="headerlink" title="3.配置PicGo"></a>3.配置PicGo</h3><p><img src="https://gitee.com/baibai1293205470/image-save/raw/master/image-20250313180259330.png" alt="image-20250313180259330"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Redis-SpringBoot整合Redis</title>
      <link href="/2025/03/13/%E6%9A%82%E5%AD%98/Redis-SpringBoot%E6%95%B4%E5%90%88Redis/"/>
      <url>/2025/03/13/%E6%9A%82%E5%AD%98/Redis-SpringBoot%E6%95%B4%E5%90%88Redis/</url>
      
        <content type="html"><![CDATA[<h2 id="Spring-Cache"><a href="#Spring-Cache" class="headerlink" title="Spring Cache"></a>Spring Cache</h2><h3 id="1-常用注解"><a href="#1-常用注解" class="headerlink" title="1.常用注解"></a>1.常用注解</h3><p><img src="https://cdn.nlark.com/yuque/0/2025/png/29145772/1741598755740-8b1e3334-e29c-4169-b741-a63ce55d21e6.png"></p><h3 id="2-使用"><a href="#2-使用" class="headerlink" title="2.使用"></a>2.使用</h3><p><font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">在spring boot项目中导入相关缓存技术的依赖包，并在启动类上使用(@EnableCaching开启缓存支持即可。</font><br><font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(252, 252, 252);">例如，使用Redis作为缓存技术，只需要导入Spring data Redis的maven坐标即可。<br></font><img src="https://gitee.com/baiseventeen/image-save/raw/master/1741599163396-f49aed30-e434-4a73-ac73-1dac86a388f5.png"></p><p><img src="https://cdn.nlark.com/yuque/0/2025/png/29145772/1741599918767-99a18409-20d7-414e-ab0c-8dec9c954587.png"></p><p>不设置有效期则永久有效</p><p><img src="https://gitee.com/baiseventeen/image-save/raw/master/1741600004991-d700d094-44db-426a-8caa-22658677d707.png"></p><h2 id="使用Redis实现旁行榜功能"><a href="#使用Redis实现旁行榜功能" class="headerlink" title="使用Redis实现旁行榜功能"></a>使用Redis实现旁行榜功能</h2><p><font style="background-color:rgb(252, 252, 252);">尝试用Redis实现一个简单的排行榜（如游戏积分），直接给我Java代码</font></p><p><font style="background-color:rgb(252, 252, 252);">已深度思考（用时13秒）</font></p><p><font style="color:rgba(0, 0, 0, 0.6);background-color:rgb(252, 252, 252);">好的，用户让我用Java代码实现一个基于Redis的简单排行榜，比如游戏积分。首先，我需要回忆一下Redis的有序集合（Sorted Set）相关命令，因为这是实现排行榜的关键数据结构。有序集合中的每个成员都有一个分数，可以按分数排序，非常适合用来做排行榜。</font></p><p><font style="color:rgba(0, 0, 0, 0.6);background-color:rgb(252, 252, 252);">接下来，我需要确定用户可能的需求。用户可能希望有添加积分、更新积分、获取排行榜前N名、以及获取某个用户的排名和积分这些基本功能。此外，用户可能希望代码简洁，并且使用Java的Redis客户端，比如Jedis。</font></p><p><font style="color:rgba(0, 0, 0, 0.6);background-color:rgb(252, 252, 252);">然后，我得考虑代码的结构。首先需要引入Jedis依赖，然后在代码中连接到Redis服务器。接着，定义一些常量，比如排行榜的键名。之后，编写添加或更新用户积分的方法，使用ZADD命令。获取前N名可以使用ZREVRANGE命令，因为分数从高到低排序。获取单个用户的排名可以用ZREVRANK，积分可以用ZSCORE。</font></p><p><font style="color:rgba(0, 0, 0, 0.6);background-color:rgb(252, 252, 252);">需要注意的是，Jedis的方法可能返回不同的数据类型，比如ZREVRANGE返回的是Set，而ZREVRANK返回的是Long，需要考虑空值情况。此外，异常处理也是必要的，比如连接失败的情况，但为了示例简洁，可能暂时不处理，但在实际应用中需要添加。</font></p><p><font style="color:rgba(0, 0, 0, 0.6);background-color:rgb(252, 252, 252);">然后，测试这些方法是否正确。比如添加几个用户的积分，然后查询排行榜，查看是否按分数降序排列。同时检查获取单个用户排名和积分是否正确。</font></p><p><font style="color:rgba(0, 0, 0, 0.6);background-color:rgb(252, 252, 252);">可能还需要考虑分数相同的情况，Redis会按字典序排序，但用户可能希望积分相同的按时间排序，这时候可能需要额外处理，比如将时间戳作为分数的一部分，但示例中可能暂时不涉及。</font></p><p><font style="color:rgba(0, 0, 0, 0.6);background-color:rgb(252, 252, 252);">最后，确保代码示例是完整的，用户可以复制粘贴并运行，可能需要补充Maven依赖和主方法中的测试代码。</font></p><p><font style="background-color:rgb(252, 252, 252);">以下是用 Java 和 Jedis 客户端实现 Redis 排行榜的完整代码示例，包含积分更新、排行榜查询等功能：</font></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line">java</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">import redis.clients.jedis.Jedis;</span><br><span class="line">import java.util.Set;</span><br><span class="line"></span><br><span class="line">public class RedisLeaderboard &#123;</span><br><span class="line">    private static final String LEADERBOARD_KEY = &quot;game_leaderboard&quot;;</span><br><span class="line">    private static final String REDIS_HOST = &quot;localhost&quot;;</span><br><span class="line">    private static final int REDIS_PORT = 6379;</span><br><span class="line"></span><br><span class="line">    private Jedis jedis;</span><br><span class="line"></span><br><span class="line">    public RedisLeaderboard() &#123;</span><br><span class="line">        // 连接 Redis</span><br><span class="line">        jedis = new Jedis(REDIS_HOST, REDIS_PORT);</span><br><span class="line">        System.out.println(&quot;Redis连接成功&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 添加/更新用户积分</span><br><span class="line">     * @param userId 用户ID</span><br><span class="line">     * @param score 积分（double类型保证精度）</span><br><span class="line">     */</span><br><span class="line">    public void addOrUpdateUser(String userId, double score) &#123;</span><br><span class="line">        jedis.zadd(LEADERBOARD_KEY, score, userId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 获取前N名排行榜</span><br><span class="line">     * @param topN 前多少名</span><br><span class="line">     * @return 用户ID集合（按分数从高到低排序）</span><br><span class="line">     */</span><br><span class="line">    public Set&lt;String&gt; getTopPlayers(int topN) &#123;</span><br><span class="line">        // ZREVRANGE 按分数从高到低排序</span><br><span class="line">        return jedis.zrevrange(LEADERBOARD_KEY, 0, topN - 1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 获取用户排名</span><br><span class="line">     * @param userId 用户ID</span><br><span class="line">     * @return 排名（从0开始，null表示用户不存在）</span><br><span class="line">     */</span><br><span class="line">    public Long getUserRank(String userId) &#123;</span><br><span class="line">        // ZREVRANK 获取从高到低的排名</span><br><span class="line">        return jedis.zrevrank(LEADERBOARD_KEY, userId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 获取用户积分</span><br><span class="line">     * @param userId 用户ID</span><br><span class="line">     * @return 积分值</span><br><span class="line">     */</span><br><span class="line">    public Double getUserScore(String userId) &#123;</span><br><span class="line">        return jedis.zscore(LEADERBOARD_KEY, userId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        RedisLeaderboard leaderboard = new RedisLeaderboard();</span><br><span class="line">        </span><br><span class="line">        // 清空旧数据（仅测试用）</span><br><span class="line">        leaderboard.jedis.del(LEADERBOARD_KEY);</span><br><span class="line"></span><br><span class="line">        // 添加测试数据</span><br><span class="line">        leaderboard.addOrUpdateUser(&quot;user1&quot;, 1500.5);</span><br><span class="line">        leaderboard.addOrUpdateUser(&quot;user2&quot;, 2300.0);</span><br><span class="line">        leaderboard.addOrUpdateUser(&quot;user3&quot;, 3200.75);</span><br><span class="line">        leaderboard.addOrUpdateUser(&quot;user4&quot;, 1800.25);</span><br><span class="line"></span><br><span class="line">        // 更新用户积分</span><br><span class="line">        leaderboard.addOrUpdateUser(&quot;user2&quot;, 3500.0);  // user2 积分更新</span><br><span class="line"></span><br><span class="line">        // 获取前3名</span><br><span class="line">        Set&lt;String&gt; top3 = leaderboard.getTopPlayers(3);</span><br><span class="line">        System.out.println(&quot;Top 3 Players: &quot; + top3);  // 应该输出 [user2, user3, user4]</span><br><span class="line"></span><br><span class="line">        // 获取用户排名和积分</span><br><span class="line">        String targetUser = &quot;user3&quot;;</span><br><span class="line">        Long rank = leaderboard.getUserRank(targetUser);</span><br><span class="line">        Double score = leaderboard.getUserScore(targetUser);</span><br><span class="line">        </span><br><span class="line">        if (rank != null &amp;&amp; score != null) &#123;</span><br><span class="line">            System.out.println(targetUser + &quot; 排名: &quot; + (rank + 1) + &quot;, 积分: &quot; + score);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            System.out.println(&quot;用户不存在&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 关闭连接</span><br><span class="line">        leaderboard.jedis.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="需要添加-Maven-依赖："><a href="#需要添加-Maven-依赖：" class="headerlink" title="需要添加 Maven 依赖："></a><font style="background-color:rgb(252, 252, 252);">需要添加 Maven 依赖：</font></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">xml</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;redis.clients&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;jedis&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;4.3.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h4 id="代码说明："><a href="#代码说明：" class="headerlink" title="代码说明："></a><font style="background-color:rgb(252, 252, 252);">代码说明：</font></h4><ol><li><strong><font style="background-color:rgb(252, 252, 252);">核心数据结构</font></strong><font style="background-color:rgb(252, 252, 252);">：使用 Redis 的</font><font style="background-color:rgb(252, 252, 252);"> </font><code>&lt;font style=&quot;background-color:rgb(252, 252, 252);&quot;&gt;ZSET&lt;/font&gt;</code><font style="background-color:rgb(252, 252, 252);">（有序集合），通过</font><font style="background-color:rgb(252, 252, 252);"> </font><code>&lt;font style=&quot;background-color:rgb(252, 252, 252);&quot;&gt;ZADD&lt;/font&gt;</code><font style="background-color:rgb(252, 252, 252);"> </font><font style="background-color:rgb(252, 252, 252);">添加/更新积分，自动维护排序</font></li><li><strong><font style="background-color:rgb(252, 252, 252);">关键操作</font></strong><font style="background-color:rgb(252, 252, 252);">：</font><ul><li><code>&lt;font style=&quot;background-color:rgb(252, 252, 252);&quot;&gt;zrevrange&lt;/font&gt;</code><font style="background-color:rgb(252, 252, 252);">：获取降序排列的排行榜</font></li><li><code>&lt;font style=&quot;background-color:rgb(252, 252, 252);&quot;&gt;zrevrank&lt;/font&gt;</code><font style="background-color:rgb(252, 252, 252);">：获取用户排名（从高到低）</font></li><li><code>&lt;font style=&quot;background-color:rgb(252, 252, 252);&quot;&gt;zscore&lt;/font&gt;</code><font style="background-color:rgb(252, 252, 252);">：获取用户当前积分</font></li></ul></li><li><strong><font style="background-color:rgb(252, 252, 252);">分数类型</font></strong><font style="background-color:rgb(252, 252, 252);">：使用</font><font style="background-color:rgb(252, 252, 252);"> </font><code>&lt;font style=&quot;background-color:rgb(252, 252, 252);&quot;&gt;double&lt;/font&gt;</code><font style="background-color:rgb(252, 252, 252);"> </font><font style="background-color:rgb(252, 252, 252);">类型保证精度，适合需要小数积分的场景</font></li><li><strong><font style="background-color:rgb(252, 252, 252);">扩展性</font></strong><font style="background-color:rgb(252, 252, 252);">：可以通过添加以下功能增强：</font></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">java</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 获取积分区间用户（例如 2000-3000分的用户）</span><br><span class="line">jedis.zrangeByScoreWithScores(LEADERBOARD_KEY, 2000, 3000);</span><br><span class="line"></span><br><span class="line">// 增加积分（而不是直接设置）</span><br><span class="line">jedis.zincrby(LEADERBOARD_KEY, 100.0, &quot;user1&quot;);</span><br></pre></td></tr></table></figure><h4 id="实际运行结果："><a href="#实际运行结果：" class="headerlink" title="实际运行结果："></a><font style="background-color:rgb(252, 252, 252);">实际运行结果：</font></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Redis连接成功</span><br><span class="line">Top 3 Players: [user2, user3, user4]</span><br><span class="line">user3 排名: 2, 积分: 3200.75</span><br></pre></td></tr></table></figure><p><font style="background-color:rgb(252, 252, 252);">如果需要处理分布式环境或高并发场景，可以：</font></p><ol><li><font style="background-color:rgb(252, 252, 252);">使用连接池 (</font><code>&lt;font style=&quot;background-color:rgb(252, 252, 252);&quot;&gt;JedisPool&lt;/font&gt;</code><font style="background-color:rgb(252, 252, 252);">)</font></li><li><font style="background-color:rgb(252, 252, 252);">添加事务支持 (</font><code>&lt;font style=&quot;background-color:rgb(252, 252, 252);&quot;&gt;Transaction&lt;/font&gt;</code><font style="background-color:rgb(252, 252, 252);">)</font></li><li><font style="background-color:rgb(252, 252, 252);">使用 Lua 脚本保证原子性操作</font></li></ol><p><font style="background-color:rgb(252, 252, 252);">如果积分本来是存储于mysql中的，那么该怎么办，使用springboot+redisTemplate给我演示</font></p><p><font style="background-color:rgb(252, 252, 252);">已深度思考（用时20秒）</font></p><p><font style="color:rgba(0, 0, 0, 0.6);background-color:rgb(252, 252, 252);">好的，我现在需要帮用户解决如何在使用Spring Boot和RedisTemplate的情况下，将原本存储在MySQL中的积分同步到Redis，并实现排行榜功能。用户之前已经得到了一个使用Jedis的Java示例，现在希望用Spring Boot和RedisTemplate来实现，并且涉及到与MySQL的集成。</font></p><p><font style="color:rgba(0, 0, 0, 0.6);background-color:rgb(252, 252, 252);">首先，我得理解用户的需求。他们有一个现有的系统，用户积分存储在MySQL中，现在需要引入Redis来实现排行榜，可能因为直接查询MySQL的排序性能不够，或者需要实时更新排行榜。因此，需要将MySQL中的数据同步到Redis的有序集合中，并通过RedisTemplate来操作。</font></p><p><font style="color:rgba(0, 0, 0, 0.6);background-color:rgb(252, 252, 252);">接下来，我需要考虑如何设计这个同步过程。可能有两种情况：初始同步和实时同步。初始同步是指将MySQL中现有的积分数据一次性导入到Redis。实时同步则是在MySQL积分更新时，同时更新Redis中的数据。用户的问题可能更关注实时同步，但初始同步也是必要的。</font></p><p><font style="color:rgba(0, 0, 0, 0.6);background-color:rgb(252, 252, 252);">然后，要确定使用Spring Boot中的哪些组件。常见的做法是使用JPA或MyBatis作为MySQL的ORM框架，使用RedisTemplate来操作Redis。这里可能需要定义实体类、Repository接口，以及服务类来处理业务逻辑。</font></p><p><font style="color:rgba(0, 0, 0, 0.6);background-color:rgb(252, 252, 252);">在代码结构方面，需要配置Redis连接，定义RedisTemplate的Bean，可能需要自定义序列化方式，因为默认的JDK序列化不适合阅读和调试。通常会将key和hash key设置为字符串序列化，而value使用JSON序列化。</font></p><p><font style="color:rgba(0, 0, 0, 0.6);background-color:rgb(252, 252, 252);">接下来，考虑如何将MySQL中的数据同步到Redis。可能需要在服务层中，当查询用户积分时，先查Redis，如果不存在则从MySQL加载，并写入Redis。或者在每次更新MySQL积分时，同时更新Redis中的对应积分。这里需要处理数据一致性问题，比如使用事务或异步更新，但需要权衡一致性和性能。</font></p><p><font style="color:rgba(0, 0, 0, 0.6);background-color:rgb(252, 252, 252);">对于排行榜功能，使用Redis的有序集合（ZSET）是合适的。每次更新用户积分时，使用RedisTemplate的opsForZSet().add方法更新积分。获取排行榜时，使用reverseRangeWithScores方法获取前N名。</font></p><p><font style="color:rgba(0, 0, 0, 0.6);background-color:rgb(252, 252, 252);">还需要考虑如何定时同步或处理可能的同步失败情况，比如使用Spring的Scheduled注解定时同步，或者使用消息队列来确保同步的可靠性。不过用户可能只需要基础的同步，暂时不需要复杂机制。</font></p><p><font style="color:rgba(0, 0, 0, 0.6);background-color:rgb(252, 252, 252);">现在，我需要编写示例代码，展示如何配置RedisTemplate，如何定义实体和Repository，以及如何在服务层中同步数据。同时，需要演示更新积分和获取排行榜的方法。</font></p><p><font style="color:rgba(0, 0, 0, 0.6);background-color:rgb(252, 252, 252);">可能遇到的问题包括Redis和MySQL的数据不一致，比如当MySQL更新成功但Redis更新失败时，如何处理。可能需要事务管理，但Redis的事务与MySQL的事务不同，需要谨慎处理。或者使用补偿机制，在检测到不一致时进行修复。</font></p><p><font style="color:rgba(0, 0, 0, 0.6);background-color:rgb(252, 252, 252);">最后，需要测试代码，确保当MySQL中的数据更新时，Redis中的排行榜也会相应更新，并且获取排行榜的方法正确返回结果。</font></p><p><font style="background-color:rgb(252, 252, 252);">以下是基于 Spring Boot + RedisTemplate + MySQL 的完整解决方案，包含 </font><strong><font style="background-color:rgb(252, 252, 252);">MySQL 数据同步到 Redis</font></strong><font style="background-color:rgb(252, 252, 252);"> </font><font style="background-color:rgb(252, 252, 252);">和 </font><strong><font style="background-color:rgb(252, 252, 252);">实时排行榜查询</font></strong><font style="background-color:rgb(252, 252, 252);"> </font><font style="background-color:rgb(252, 252, 252);">功能：</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line">java</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 实体类 UserScore.java （MySQL映射）</span></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Table(name = &quot;user_score&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserScore</span> &#123;</span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@GeneratedValue(strategy = GenerationType.IDENTITY)</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Column(unique = true)</span></span><br><span class="line">    <span class="keyword">private</span> String userId;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Double score; <span class="comment">// 使用Double类型保证精度</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Getters and Setters</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. MySQL Repository 接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserScoreRepository</span> <span class="keyword">extends</span> <span class="title class_">JpaRepository</span>&lt;UserScore, Long&gt; &#123;</span><br><span class="line">    UserScore <span class="title function_">findByUserId</span><span class="params">(String userId)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. Redis 配置类 RedisConfig.java</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RedisTemplate&lt;String, Object&gt; <span class="title function_">redisTemplate</span><span class="params">(RedisConnectionFactory factory)</span> &#123;</span><br><span class="line">        RedisTemplate&lt;String, Object&gt; template = <span class="keyword">new</span> <span class="title class_">RedisTemplate</span>&lt;&gt;();</span><br><span class="line">        template.setConnectionFactory(factory);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用String序列化Key</span></span><br><span class="line">        <span class="type">StringRedisSerializer</span> <span class="variable">stringSerializer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringRedisSerializer</span>();</span><br><span class="line">        template.setKeySerializer(stringSerializer);</span><br><span class="line">        template.setHashKeySerializer(stringSerializer);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用JSON序列化Value</span></span><br><span class="line">        Jackson2JsonRedisSerializer&lt;Object&gt; jsonSerializer = </span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Jackson2JsonRedisSerializer</span>&lt;&gt;(Object.class);</span><br><span class="line">        template.setValueSerializer(jsonSerializer);</span><br><span class="line">        template.setHashValueSerializer(jsonSerializer);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> template;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 核心服务类 LeaderboardService.java</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LeaderboardService</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">LEADERBOARD_KEY</span> <span class="operator">=</span> <span class="string">&quot;game_leaderboard&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserScoreRepository userScoreRepository;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate&lt;String, Object&gt; redisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新积分（同步到MySQL和Redis）</span></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateScore</span><span class="params">(String userId, <span class="type">double</span> newScore)</span> &#123;</span><br><span class="line">        <span class="comment">// 1. 更新MySQL</span></span><br><span class="line">        <span class="type">UserScore</span> <span class="variable">userScore</span> <span class="operator">=</span> userScoreRepository.findByUserId(userId)</span><br><span class="line">        .orElseGet(() -&gt; <span class="keyword">new</span> <span class="title class_">UserScore</span>(userId, newScore));</span><br><span class="line">        userScore.setScore(newScore);</span><br><span class="line">        userScoreRepository.save(userScore);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 同步到Redis</span></span><br><span class="line">        redisTemplate.opsForZSet().add(LEADERBOARD_KEY, userId, newScore);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取实时排行榜（前N名）</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Map.Entry&lt;String, Double&gt;&gt; getTopPlayers(<span class="type">int</span> topN) &#123;</span><br><span class="line">        Set&lt;ZSetOperations.TypedTuple&lt;Object&gt;&gt; typedTuples = </span><br><span class="line">        redisTemplate.opsForZSet().reverseRangeWithScores(LEADERBOARD_KEY, <span class="number">0</span>, topN - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> typedTuples.stream()</span><br><span class="line">        .map(tuple -&gt; &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">userId</span> <span class="operator">=</span> (String) tuple.getValue();</span><br><span class="line">            <span class="type">Double</span> <span class="variable">score</span> <span class="operator">=</span> tuple.getScore();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">AbstractMap</span>.SimpleEntry&lt;&gt;(userId, score);</span><br><span class="line">        &#125;)</span><br><span class="line">        .collect(Collectors.toList());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化时从MySQL加载数据到Redis（项目启动后执行一次）</span></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">initRedisLeaderboard</span><span class="params">()</span> &#123;</span><br><span class="line">        List&lt;UserScore&gt; allScores = userScoreRepository.findAll();</span><br><span class="line"></span><br><span class="line">        allScores.forEach(userScore -&gt; </span><br><span class="line">                          redisTemplate.opsForZSet().add(</span><br><span class="line">                              LEADERBOARD_KEY, </span><br><span class="line">                              userScore.getUserId(), </span><br><span class="line">                              userScore.getScore()</span><br><span class="line">            )</span><br><span class="line">        );</span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">&quot;已从MySQL初始化排行榜数据到Redis&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 5. 控制器 LeaderboardController.java</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/leaderboard&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LeaderboardController</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> LeaderboardService leaderboardService;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@PostMapping(&quot;/update&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> ResponseEntity&lt;?&gt; updateScore(</span><br><span class="line">        <span class="meta">@RequestParam</span> String userId,</span><br><span class="line">        <span class="meta">@RequestParam</span> <span class="type">double</span> score</span><br><span class="line">    ) &#123;</span><br><span class="line">        leaderboardService.updateScore(userId, score);</span><br><span class="line">        <span class="keyword">return</span> ResponseEntity.ok().build();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@GetMapping(&quot;/top&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> ResponseEntity&lt;List&lt;Map.Entry&lt;String, Double&gt;&gt;&gt; getTop(</span><br><span class="line">        <span class="meta">@RequestParam(defaultValue = &quot;10&quot;)</span> <span class="type">int</span> topN</span><br><span class="line">    ) &#123;</span><br><span class="line">        <span class="keyword">return</span> ResponseEntity.ok(leaderboardService.getTopPlayers(topN));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="关键实现细节说明："><a href="#关键实现细节说明：" class="headerlink" title="关键实现细节说明："></a><font style="background-color:rgb(252, 252, 252);">关键实现细节说明：</font></h4><ol><li><strong><font style="background-color:rgb(252, 252, 252);">双写一致性</font></strong><font style="background-color:rgb(252, 252, 252);">：</font><ul><li><font style="background-color:rgb(252, 252, 252);">使用</font><font style="background-color:rgb(252, 252, 252);"> </font><code>&lt;font style=&quot;background-color:rgb(252, 252, 252);&quot;&gt;@Transactional&lt;/font&gt;</code><font style="background-color:rgb(252, 252, 252);"> </font><font style="background-color:rgb(252, 252, 252);">保证 MySQL 更新原子性</font></li><li><font style="background-color:rgb(252, 252, 252);">Redis 更新放在事务之后（建议放在最后），若 Redis 更新失败需记录日志补偿</font></li><li><font style="background-color:rgb(252, 252, 252);">启动时通过</font><font style="background-color:rgb(252, 252, 252);"> </font><code>&lt;font style=&quot;background-color:rgb(252, 252, 252);&quot;&gt;@PostConstruct&lt;/font&gt;</code><font style="background-color:rgb(252, 252, 252);"> </font><font style="background-color:rgb(252, 252, 252);">执行全量同步</font></li></ul></li><li><strong><font style="background-color:rgb(252, 252, 252);">性能优化</font></strong><font style="background-color:rgb(252, 252, 252);">：</font><ul><li><font style="background-color:rgb(252, 252, 252);">使用</font><font style="background-color:rgb(252, 252, 252);"> </font><code>&lt;font style=&quot;background-color:rgb(252, 252, 252);&quot;&gt;reverseRangeWithScores&lt;/font&gt;</code><font style="background-color:rgb(252, 252, 252);"> </font><font style="background-color:rgb(252, 252, 252);">直接获取带分数的排行榜数据</font></li><li><font style="background-color:rgb(252, 252, 252);">Redis 使用 ZSET 结构，时间复杂度 O(log N) 保证高效</font></li></ul></li><li><strong><font style="background-color:rgb(252, 252, 252);">扩展建议</font></strong><font style="background-color:rgb(252, 252, 252);">：</font></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">java</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 异步补偿机制（使用Spring Retry）</span></span><br><span class="line"><span class="meta">@Retryable(maxAttempts = 3, backoff = @Backoff(delay = 1000))</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">syncToRedis</span><span class="params">(String userId, <span class="type">double</span> score)</span> &#123;</span><br><span class="line">    redisTemplate.opsForZSet().add(LEADERBOARD_KEY, userId, score);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 增量更新积分（代替直接设置新值）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">incrementScore</span><span class="params">(String userId, <span class="type">double</span> delta)</span> &#123;</span><br><span class="line">    <span class="comment">// MySQL操作</span></span><br><span class="line">    userScoreRepository.incrementScore(userId, delta);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Redis原子操作</span></span><br><span class="line">    redisTemplate.opsForZSet().incrementScore(LEADERBOARD_KEY, userId, delta);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li><strong><font style="background-color:rgb(252, 252, 252);">配置示例（application.yml）</font></strong><font style="background-color:rgb(252, 252, 252);">：</font></li></ol><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">yaml</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/game_db</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">your_mysql_password</span></span><br><span class="line">  <span class="attr">jpa:</span></span><br><span class="line">    <span class="attr">hibernate:</span></span><br><span class="line">      <span class="attr">ddl-auto:</span> <span class="string">update</span></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="string">localhost</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">6379</span></span><br><span class="line">    <span class="comment"># password: your_redis_password (如有)</span></span><br></pre></td></tr></table></figure><h4 id="测试用例示例："><a href="#测试用例示例：" class="headerlink" title="测试用例示例："></a><font style="background-color:rgb(252, 252, 252);">测试用例示例：</font></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">java</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testLeaderboardFlow</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 1. 更新用户A积分到100</span></span><br><span class="line">    leaderboardService.updateScore(<span class="string">&quot;userA&quot;</span>, <span class="number">100.0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 查询前3名</span></span><br><span class="line">    List&lt;Map.Entry&lt;String, Double&gt;&gt; top3 = leaderboardService.getTopPlayers(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 验证结果</span></span><br><span class="line">    assertEquals(<span class="number">100.0</span>, top3.get(<span class="number">0</span>).getValue(), <span class="number">0.001</span>);</span><br><span class="line">    assertEquals(<span class="string">&quot;userA&quot;</span>, top3.get(<span class="number">0</span>).getKey());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 检查MySQL数据</span></span><br><span class="line">    <span class="type">UserScore</span> <span class="variable">userA</span> <span class="operator">=</span> userScoreRepository.findByUserId(<span class="string">&quot;userA&quot;</span>).orElseThrow();</span><br><span class="line">    assertEquals(<span class="number">100.0</span>, userA.getScore(), <span class="number">0.001</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><font style="background-color:rgb(252, 252, 252);">这个方案实现了 </font><strong><font style="background-color:rgb(252, 252, 252);">MySQL 作为权威数据源</font></strong><font style="background-color:rgb(252, 252, 252);"> </font><font style="background-color:rgb(252, 252, 252);">+ </font><strong><font style="background-color:rgb(252, 252, 252);">Redis 作为高性能排行榜缓存</font></strong><font style="background-color:rgb(252, 252, 252);"> </font><font style="background-color:rgb(252, 252, 252);">的经典组合，可以应对高并发查询场景，同时保证数据持久化。</font></p><p><font style="background-color:rgb(252, 252, 252);">redis用注解的形式呢</font></p><p><font style="background-color:rgb(252, 252, 252);">已深度思考（用时16秒）</font></p><p><font style="color:rgba(0, 0, 0, 0.6);background-color:rgb(252, 252, 252);">好的，用户之前让我用Spring Boot和RedisTemplate实现一个基于MySQL和Redis的排行榜系统。现在用户问的是“redis用注解的形式呢”，我需要理解他们的需求。看起来用户可能想要更简洁的代码，或者想利用Spring的缓存注解来简化Redis操作，比如@Cacheable、@CachePut等。</font></p><p><font style="color:rgba(0, 0, 0, 0.6);background-color:rgb(252, 252, 252);">首先，我要回顾之前给出的方案，其中使用了RedisTemplate直接操作ZSet，这给了用户很大的灵活性。但用户现在希望用注解的方式，可能希望减少样板代码，或者让缓存逻辑更声明式。</font></p><p><font style="color:rgba(0, 0, 0, 0.6);background-color:rgb(252, 252, 252);">接下来，我需要考虑如何将排行榜的功能与Spring Cache的注解结合。不过，标准的Spring Cache注解（如@Cacheable）主要针对简单的键值缓存，可能不适合有序集合的操作。例如，排行榜需要ZADD、ZREVRANGE等操作，这些可能无法直接通过注解来实现。</font></p><p><font style="color:rgba(0, 0, 0, 0.6);background-color:rgb(252, 252, 252);">可能需要自定义注解和切面来处理排行榜的特殊需求。比如，定义一个@UpdateScore注解，当方法被调用时，自动更新Redis中的有序集合。或者，@GetTopPlayers注解来触发查询排行榜的逻辑。</font></p><p><font style="color:rgba(0, 0, 0, 0.6);background-color:rgb(252, 252, 252);">同时，还要考虑如何将MySQL的数据同步到Redis。之前的方案是在服务启动时从MySQL加载数据，并通过updateScore方法双写。如果用注解，可能需要在这些方法上添加缓存操作的切面，确保数据一致性。</font></p><p><font style="color:rgba(0, 0, 0, 0.6);background-color:rgb(252, 252, 252);">另外，用户可能希望保持代码的简洁，利用已有的Spring Cache机制，但需要扩展它来支持有序集合。例如，自定义一个Redis缓存管理器，处理ZSet相关的操作。</font></p><p><font style="color:rgba(0, 0, 0, 0.6);background-color:rgb(252, 252, 252);">还需要注意，使用注解可能会限制一些灵活性，比如复杂的查询或事务处理，这时候需要在注解和直接操作RedisTemplate之间找到平衡。</font></p><p><font style="color:rgba(0, 0, 0, 0.6);background-color:rgb(252, 252, 252);">总结下来，用户的真实需求可能是简化代码，减少显式的Redis操作，通过声明式注解来自动处理缓存的更新和查询。因此，我需要设计一些自定义注解，结合AOP，在方法调用前后自动执行Redis的有序集合操作，同时保持与MySQL的数据同步。</font></p><p><font style="background-color:rgb(252, 252, 252);">以下是使用 </font><strong><font style="background-color:rgb(252, 252, 252);">Spring Cache 注解</font></strong><font style="background-color:rgb(252, 252, 252);"> </font><font style="background-color:rgb(252, 252, 252);">结合 Redis 的实现方式，通过自定义注解和AOP简化排行榜操作：</font></p><h3 id="1-添加依赖"><a href="#1-添加依赖" class="headerlink" title="1. 添加依赖"></a>1. 添加依赖</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">xml</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-cache<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="2-自定义排行榜注解"><a href="#2-自定义排行榜注解" class="headerlink" title="2. 自定义排行榜注解"></a><font style="background-color:rgb(252, 252, 252);">2. 自定义排行榜注解</font></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">java</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 更新积分的自定义注解</span></span><br><span class="line"><span class="meta">@Target(ElementType.METHOD)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> UpdateRank &#123;</span><br><span class="line">    String <span class="title function_">key</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;leaderboard&quot;</span>;  <span class="comment">// Redis键名</span></span><br><span class="line">    String <span class="title function_">userIdSpEL</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;     <span class="comment">// 用户ID的SpEL表达式</span></span><br><span class="line">    String <span class="title function_">scoreSpEL</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;      <span class="comment">// 积分的SpEL表达式</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查询排行榜的自定义注解</span></span><br><span class="line"><span class="meta">@Target(ElementType.METHOD)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> GetTopRank &#123;</span><br><span class="line">    String <span class="title function_">key</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;leaderboard&quot;</span>;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">topN</span><span class="params">()</span> <span class="keyword">default</span> <span class="number">10</span>;              <span class="comment">// 前N名</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-注解切面处理类"><a href="#3-注解切面处理类" class="headerlink" title="3. 注解切面处理类"></a><font style="background-color:rgb(252, 252, 252);">3. 注解切面处理类</font></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">java</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LeaderboardAspect</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate&lt;String, Object&gt; redisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理积分更新</span></span><br><span class="line">    <span class="meta">@Around(&quot;@annotation(updateRank)&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">updateRank</span><span class="params">(ProceedingJoinPoint joinPoint, UpdateRank updateRank)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="comment">// 1. 执行原方法（通常包含MySQL操作）</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> joinPoint.proceed();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 解析SpEL表达式获取参数值</span></span><br><span class="line">        <span class="type">EvaluationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StandardEvaluationContext</span>(joinPoint.getArgs());</span><br><span class="line">        <span class="type">String</span> <span class="variable">userId</span> <span class="operator">=</span> parseSpEL(updateRank.userIdSpEL(), joinPoint);</span><br><span class="line">        <span class="type">Double</span> <span class="variable">score</span> <span class="operator">=</span> parseSpEL(updateRank.scoreSpEL(), joinPoint, Double.class);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 更新Redis排行榜</span></span><br><span class="line">        redisTemplate.opsForZSet().add(updateRank.key(), userId, score);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理排行榜查询</span></span><br><span class="line">    <span class="meta">@Around(&quot;@annotation(getTopRank)&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">getTopRank</span><span class="params">(ProceedingJoinPoint joinPoint, GetTopRank getTopRank)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="comment">// 直接从Redis获取数据，不执行原方法</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> getTopRank.key();</span><br><span class="line">        <span class="type">int</span> <span class="variable">topN</span> <span class="operator">=</span> getTopRank.topN();</span><br><span class="line"></span><br><span class="line">        Set&lt;ZSetOperations.TypedTuple&lt;Object&gt;&gt; tuples = </span><br><span class="line">        redisTemplate.opsForZSet().reverseRangeWithScores(key, <span class="number">0</span>, topN - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> tuples.stream()</span><br><span class="line">        .map(t -&gt; <span class="keyword">new</span> <span class="title class_">AbstractMap</span>.SimpleEntry&lt;&gt;(</span><br><span class="line">            (String)t.getValue(), </span><br><span class="line">            t.getScore())</span><br><span class="line">            )</span><br><span class="line">        .collect(Collectors.toList());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解析SpEL表达式工具方法</span></span><br><span class="line">    <span class="keyword">private</span> &lt;T&gt; T <span class="title function_">parseSpEL</span><span class="params">(String spEL, JoinPoint joinPoint, Class&lt;T&gt; clazz)</span> &#123;</span><br><span class="line">        <span class="type">ExpressionParser</span> <span class="variable">parser</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SpelExpressionParser</span>();</span><br><span class="line">        <span class="type">Expression</span> <span class="variable">expression</span> <span class="operator">=</span> parser.parseExpression(spEL);</span><br><span class="line">        <span class="type">EvaluationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StandardEvaluationContext</span>();</span><br><span class="line">        context.setVariable(<span class="string">&quot;args&quot;</span>, joinPoint.getArgs());</span><br><span class="line">        <span class="keyword">return</span> expression.getValue(context, clazz);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-业务层使用注解"><a href="#4-业务层使用注解" class="headerlink" title="4. 业务层使用注解"></a><font style="background-color:rgb(252, 252, 252);">4. 业务层使用注解</font></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">java</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GameService</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserRepository userRepository;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新积分（自动同步到Redis）</span></span><br><span class="line">    <span class="meta">@UpdateRank(</span></span><br><span class="line"><span class="meta">        userIdSpEL = &quot;#user.id&quot;, </span></span><br><span class="line"><span class="meta">        scoreSpEL = &quot;#user.score&quot;</span></span><br><span class="line"><span class="meta">    )</span></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">updateUserScore</span><span class="params">(User user)</span> &#123;</span><br><span class="line">        <span class="comment">// 1. 保存到MySQL</span></span><br><span class="line">        <span class="keyword">return</span> userRepository.save(user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取排行榜（直接从Redis读取）</span></span><br><span class="line">    <span class="meta">@GetTopRank(topN = 5)</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Map.Entry&lt;String, Double&gt;&gt; getLeaderboard() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>; <span class="comment">// 实际不会执行，由切面处理</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-控制器示例"><a href="#5-控制器示例" class="headerlink" title="5. 控制器示例"></a><font style="background-color:rgb(252, 252, 252);">5. 控制器示例</font></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">java</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/game&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GameController</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> GameService gameService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/score&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">updateScore</span><span class="params">(<span class="meta">@RequestBody</span> User user)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> gameService.updateUserScore(user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/leaderboard&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Map.Entry&lt;String, Double&gt;&gt; leaderboard() &#123;</span><br><span class="line">        <span class="keyword">return</span> gameService.getLeaderboard();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-配置类-RedisConfig-java"><a href="#6-配置类-RedisConfig-java" class="headerlink" title="6. 配置类 (RedisConfig.java)"></a><font style="background-color:rgb(252, 252, 252);">6. 配置类 (RedisConfig.java)</font></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">java</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableCaching</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RedisCacheConfiguration <span class="title function_">cacheConfiguration</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> RedisCacheConfiguration.defaultCacheConfig()</span><br><span class="line">        .serializeKeysWith(SerializationPair.fromSerializer(<span class="keyword">new</span> <span class="title class_">StringRedisSerializer</span>()))</span><br><span class="line">        .serializeValuesWith(SerializationPair.fromSerializer(<span class="keyword">new</span> <span class="title class_">GenericJackson2JsonRedisSerializer</span>()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RedisTemplate&lt;String, Object&gt; <span class="title function_">redisTemplate</span><span class="params">(RedisConnectionFactory factory)</span> &#123;</span><br><span class="line">        RedisTemplate&lt;String, Object&gt; template = <span class="keyword">new</span> <span class="title class_">RedisTemplate</span>&lt;&gt;();</span><br><span class="line">        template.setConnectionFactory(factory);</span><br><span class="line">        template.setKeySerializer(<span class="keyword">new</span> <span class="title class_">StringRedisSerializer</span>());</span><br><span class="line">        template.setHashKeySerializer(<span class="keyword">new</span> <span class="title class_">StringRedisSerializer</span>());</span><br><span class="line">        template.setValueSerializer(<span class="keyword">new</span> <span class="title class_">GenericJackson2JsonRedisSerializer</span>());</span><br><span class="line">        <span class="keyword">return</span> template;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="方案特点："><a href="#方案特点：" class="headerlink" title="方案特点："></a><font style="background-color:rgb(252, 252, 252);">方案特点：</font></h3><ol><li><strong><font style="background-color:rgb(252, 252, 252);">声明式编程</font></strong><font style="background-color:rgb(252, 252, 252);">：通过注解解耦业务逻辑与Redis操作</font></li><li><strong><font style="background-color:rgb(252, 252, 252);">SpEL支持</font></strong><font style="background-color:rgb(252, 252, 252);">：灵活获取方法参数值</font></li><li><strong><font style="background-color:rgb(252, 252, 252);">双写一致性</font></strong><font style="background-color:rgb(252, 252, 252);">：</font><ul><li><font style="background-color:rgb(252, 252, 252);">更新方法 (</font><code>&lt;font style=&quot;background-color:rgb(252, 252, 252);&quot;&gt;@UpdateRank&lt;/font&gt;</code><font style="background-color:rgb(252, 252, 252);">) 先执行MySQL操作，再更新Redis</font></li><li><font style="background-color:rgb(252, 252, 252);">查询方法 (</font><code>&lt;font style=&quot;background-color:rgb(252, 252, 252);&quot;&gt;@GetTopRank&lt;/font&gt;</code><font style="background-color:rgb(252, 252, 252);">) 完全从Redis读取</font></li></ul></li><li><strong><font style="background-color:rgb(252, 252, 252);">AOP切面</font></strong><font style="background-color:rgb(252, 252, 252);">：自动处理Redis的ZSET操作</font></li></ol><h3 id="扩展建议："><a href="#扩展建议：" class="headerlink" title="扩展建议："></a><font style="background-color:rgb(252, 252, 252);">扩展建议：</font></h3><ol><li><strong><font style="background-color:rgb(252, 252, 252);">添加补偿机制</font></strong><font style="background-color:rgb(252, 252, 252);">：在切面中添加重试逻辑</font></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">java</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Retryable(maxAttempts = 3, backoff = @Backoff(delay = 1000))</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">syncToRedis</span><span class="params">(String key, String userId, Double score)</span> &#123;</span><br><span class="line">    redisTemplate.opsForZSet().add(key, userId, score);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li><strong><font style="background-color:rgb(252, 252, 252);">初始化数据加载</font></strong><font style="background-color:rgb(252, 252, 252);">：在服务启动时从MySQL加载全量数据</font></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">java</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@PostConstruct</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">initRedisData</span><span class="params">()</span> &#123;</span><br><span class="line">    List&lt;User&gt; users = userRepository.findAll();</span><br><span class="line">    users.forEach(u -&gt; </span><br><span class="line">                  redisTemplate.opsForZSet().add(<span class="string">&quot;leaderboard&quot;</span>, u.getId(), u.getScore())</span><br><span class="line">                 );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><font style="background-color:rgb(252, 252, 252);">这种模式适合需要 </font><strong><font style="background-color:rgb(252, 252, 252);">简化缓存代码</font></strong><font style="background-color:rgb(252, 252, 252);"> 的场景，通过注解将缓存操作抽象为切面，使业务代码更专注于核心逻辑。</font></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Vue-如何降低项目node版本</title>
      <link href="/2025/03/13/%E6%9A%82%E5%AD%98/Vue-%E5%A6%82%E4%BD%95%E9%99%8D%E4%BD%8E%E9%A1%B9%E7%9B%AEnode%E7%89%88%E6%9C%AC/"/>
      <url>/2025/03/13/%E6%9A%82%E5%AD%98/Vue-%E5%A6%82%E4%BD%95%E9%99%8D%E4%BD%8E%E9%A1%B9%E7%9B%AEnode%E7%89%88%E6%9C%AC/</url>
      
        <content type="html"><![CDATA[<p>暂无较为好用的方法，建议直接以低版本node重新构建项目</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hexo操作介绍</title>
      <link href="/2025/02/27/%E6%9A%82%E5%AD%98/Hexo%E6%93%8D%E4%BD%9C%E4%BB%8B%E7%BB%8D/"/>
      <url>/2025/02/27/%E6%9A%82%E5%AD%98/Hexo%E6%93%8D%E4%BD%9C%E4%BB%8B%E7%BB%8D/</url>
      
        <content type="html"><![CDATA[<h3 id="1-hexo目录介绍"><a href="#1-hexo目录介绍" class="headerlink" title="1.hexo目录介绍"></a>1.hexo目录介绍</h3><p><img src="https://gitee.com/baiseventeen/image-save/raw/master/c70da05df90d1f05519f5d222c92b7b2.png" alt="iShot2021-12-03 16.55.54"></p><h3 id="2-更换主题"><a href="#2-更换主题" class="headerlink" title="2.更换主题"></a>2.更换主题</h3><p>到GitHub上搜索hexo主题或者hero自带的主题<a href="https://hexo.io/themes/%E3%80%82">https://hexo.io/themes/。</a></p><p>按照各自的主题文档上面一步步操作即可。</p><p>一般步骤：</p><p>1、下载解压</p><p>2、放到主题包themes文件夹下面</p><p>3、在hero配置文件_config.yml中修改为喜欢主题的名字</p><p>4、hero server启动即可访问</p><h3 id="3-更新仓库"><a href="#3-更新仓库" class="headerlink" title="3.更新仓库"></a>3.更新仓库</h3><p>本地调试完之后。就可以更新到github上了</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//清理</span><br><span class="line">hexo clean</span><br><span class="line">//构建静态文件</span><br><span class="line">hexo g</span><br><span class="line">//上传至仓库</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure><h3 id="参考博客"><a href="#参考博客" class="headerlink" title="参考博客"></a>参考博客</h3><p><a href="https://blog.csdn.net/weixin_45019350/article/details/121901433">https://blog.csdn.net/weixin_45019350/article/details/121901433</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hexo操作介绍</title>
      <link href="/2025/02/27/%E6%9A%82%E5%AD%98/%E5%B0%8F%E7%99%BD%E6%89%8B%E5%86%8C/"/>
      <url>/2025/02/27/%E6%9A%82%E5%AD%98/%E5%B0%8F%E7%99%BD%E6%89%8B%E5%86%8C/</url>
      
        <content type="html"><![CDATA[<h3 id="1-hexo目录介绍"><a href="#1-hexo目录介绍" class="headerlink" title="1.hexo目录介绍"></a>1.hexo目录介绍</h3><p><img src="https://gitee.com/baiseventeen/image-save/raw/master/c70da05df90d1f05519f5d222c92b7b2.png" alt="iShot2021-12-03 16.55.54"></p><h3 id="2-更换主题"><a href="#2-更换主题" class="headerlink" title="2.更换主题"></a>2.更换主题</h3><p>到GitHub上搜索hexo主题或者hero自带的主题<a href="https://hexo.io/themes/%E3%80%82">https://hexo.io/themes/。</a></p><p>按照各自的主题文档上面一步步操作即可。</p><p>一般步骤：</p><p>1、下载解压</p><p>2、放到主题包themes文件夹下面</p><p>3、在hero配置文件_config.yml中修改为喜欢主题的名字</p><p>4、hero server启动即可访问</p><h3 id="3-更新仓库"><a href="#3-更新仓库" class="headerlink" title="3.更新仓库"></a>3.更新仓库</h3><p>本地调试完之后。就可以更新到github上了</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//清理</span><br><span class="line">hexo clean</span><br><span class="line">//构建静态文件</span><br><span class="line">hexo g</span><br><span class="line">//上传至仓库</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure><h3 id="参考博客"><a href="#参考博客" class="headerlink" title="参考博客"></a>参考博客</h3><p><a href="https://blog.csdn.net/weixin_45019350/article/details/121901433">https://blog.csdn.net/weixin_45019350/article/details/121901433</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>git常见问题记录</title>
      <link href="/2024/10/15/%E6%9A%82%E5%AD%98/git%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
      <url>/2024/10/15/%E6%9A%82%E5%AD%98/git%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<p>git clone后报错： warning: remote HEAD refers to nonexistent ref, unable to checkout.</p><p>1、概述<br>比如我从服务器上获取 DPDK 的代码：</p><p>git clone 【地址】<br>1</p><p>发现看似代码下载下来了，但是 ls 命令后项目文件夹里的内容都是空的！！<br>可以看到最后有个 warning ：warning: remote HEAD refers to nonexistent ref, unable to checkout.</p><p>2、原因<br>git clone 代码时会默认拉取远程服务器 master 主分支下的代码，可是我创建的主分支没有用 master 命名，里面是 origin/20.11 分支，目录下 .git/refs/heads 不存在 HEAD 指向的文件，因此产生了警告。</p><p>remotes/m/master -&gt; origin/master //其余工程代码有master分支</p><p>上下对比：</p><p>remotes/m/master -&gt; origin/20.11 //本工程代码分支没有master分支导致警告</p><p>如下图显示：</p><p>ls .git/refs/heads/<br>1</p><p>3、解决方法<br>1、进入git clone 操作后，生成的项目文件夹内，使用 git branch -a 查看所有的分支</p><p>hwc@hwc:~/dpdk$ git branch -a<br>  remotes/origin/18.11.11<br>  remotes/origin/19.11.14<br>  remotes/origin/20.11<br>  remotes/origin/default<br>1<br>2<br>3<br>4<br>5<br>2、选择自己需要的分支，比如我需要获取 origin/20.11 分支上的代码，那么执行操作git checkout remotes/origin/20.11。</p><p>hwc@hwc:~/dpdk$ git checkout origin/20.11<br>Note: checking out ‘origin/20.11’.</p><p>You are in ‘detached HEAD’ state. You can look around, make experimental<br>changes and commit them, and you can discard any commits you make in this<br>state without impacting any branches by performing another checkout.</p><p>If you want to create a new branch to retain commits you create, you may<br>do so (now or later) by using -b with the checkout command again. Example:</p><p>  git checkout -b <new-branch-name></p><p>HEAD is now at d2d894a55f Add: supports the “set link-up/link-down” command.<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>3、这时候 ls 命令就能看到你想要的代码</p><p>hwc@hwc:~/dpdk$ ls<br>app         devtools  examples     lib          Makefile           mk      test<br>buildtools  doc       GNUmakefile  license      meson.build        pkg     usertools<br>config      drivers   kernel       MAINTAINERS  meson_options.txt  README<br>1<br>2<br>3<br>4<br>4、新建一个分支后，操作git log, git status等命令。</p><p>hwc@hwc:~/dpdk$ git checkout -b dev-20.11<br>Switched to a new branch ‘dev-20.11’<br>1<br>2<br>到此，解决问题！</p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
